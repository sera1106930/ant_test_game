<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Ant Net</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000000;
            --accent-cyan: #22d3ee;
            --accent-red: #ef4444;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #uiLayer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-left {
            position: absolute;
            top: 2rem;
            left: 2rem;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-left: 4px solid var(--accent-cyan);
            pointer-events: auto;
        }

        .hud-right {
            position: absolute;
            top: 2rem;
            right: 2rem;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-right: 4px solid var(--accent-cyan);
            text-align: right;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .controls {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            pointer-events: auto;
        }

        button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: cyan;
            border: 1px solid cyan;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px var(--accent-cyan);
        }

        .mock-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: yellow;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .timer-val {
            font-family: monospace;
            font-size: 1.5rem;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px var(--accent-cyan);
        }

        .progress-bar {
            width: 200px;
            height: 6px;
            background: #1e293b;
            margin-top: 5px;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-cyan);
            width: 0%;
            transition: width 0.2s;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="bgCanvas"></canvas>
        <canvas id="fogCanvas"></canvas>
        <canvas id="antCanvas"></canvas>
        <div id="uiLayer">
            <div class="mock-indicator" id="modeLabel">Connecting...</div>

            <div class="hud-left">
                <div>SYSTEM STATUS: <span style="color:#22d3ee">ONLINE</span></div>
                <div>AGENTS: <span id="antCount">0</span></div>
            </div>

            <div class="hud-right">
                <div style="font-size: 0.8rem; opacity: 0.8;">EXPLORATION TIMER</div>
                <div id="timerDisplay" class="timer-val">00:00.00</div>
                <div style="font-size: 0.8rem; margin-top: 5px;">COVERAGE: <span id="explorePct">0</span>%</div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>

            <div class="controls">
                <button id="resetBtn">REGENERATE NET</button>
                <button id="spawnBtn">DEPLOY AGENT</button>
                <button id="toggleMockBtn" style="border-color: yellow; color: yellow;">SWITCH TO REAL SERVER</button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            useMock: true,
            apiBase: 'http://localhost:8080/api',
            colors: { bg: '#000000', ground: '#1e293b', ant: '#22d3ee', antRed: '#ef4444', border: '#22d3ee' }
        };

        const API = {
            getMap: async () => {
                if (CONFIG.useMock) return MockServer.getMap();
                const res = await fetch(`${CONFIG.apiBase}/map`);
                return res.json();
            },
            getState: async () => {
                if (CONFIG.useMock) return MockServer.getState();
                const res = await fetch(`${CONFIG.apiBase}/state`);
                return res.json();
            },
            spawn: async () => {
                if (CONFIG.useMock) return MockServer.spawn();
                await fetch(`${CONFIG.apiBase}/spawn`, { method: 'POST' });
            },
            reset: async () => {
                if (CONFIG.useMock) return MockServer.reset();
                await fetch(`${CONFIG.apiBase}/reset`, { method: 'POST' });
            }
        };

        const Physics = {
            isPointInPolygon: function (point, vs) {
                var x = point.x, y = point.y;
                var inside = false;
                for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    var xi = vs[i].x, yi = vs[i].y;
                    var xj = vs[j].x, yj = vs[j].y;
                    var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            },
            isValid: function (x, y, rooms) {
                for (let r of rooms) {
                    const poly = r.points || r.poly;
                    if (this.isPointInPolygon({ x, y }, poly)) return true;
                }
                return false;
            }
        };

        class GameClient {
            constructor() {
                this.canvases = {
                    bg: document.getElementById('bgCanvas').getContext('2d'),
                    fog: document.getElementById('fogCanvas').getContext('2d'),
                    ant: document.getElementById('antCanvas').getContext('2d')
                };
                this.mapData = null;
                this.agents = [];
                this.init();
            }

            async init() {
                window.onresize = () => this.resize();
                this.resize();

                this.mapData = await API.getMap();
                MockServer.map = this.mapData;

                this.drawStaticMap();
                this.initFog();

                this.loop();
            }

            resize() {
                const w = window.innerWidth, h = window.innerHeight;
                for (let k in this.canvases) { this.canvases[k].canvas.width = w; this.canvases[k].canvas.height = h; }
                if (this.mapData) this.drawStaticMap();
            }

            drawStaticMap() {
                if (!this.mapData) return;

                const mCanvas = document.createElement('canvas');
                mCanvas.width = Math.max(6000, this.mapData.width);
                mCanvas.height = Math.max(6000, this.mapData.height);
                const mCtx = mCanvas.getContext('2d');

                // We don't need the white fill mCtx logic anymore if we draw directly to bCtx or reusing mCtx
                // But let's follow the previous pattern of creating a background image.

                const bCtx = document.createElement('canvas').getContext('2d');
                bCtx.canvas.width = mCanvas.width; bCtx.canvas.height = mCanvas.height;

                // Grid (Optional, keep faint)
                bCtx.strokeStyle = 'rgba(34, 211, 238, 0.05)';
                bCtx.lineWidth = 1;
                for (let x = 0; x < mCanvas.width; x += 100) { bCtx.beginPath(); bCtx.moveTo(x, 0); bCtx.lineTo(x, mCanvas.height); bCtx.stroke(); }
                for (let y = 0; y < mCanvas.height; y += 100) { bCtx.beginPath(); bCtx.moveTo(0, y); bCtx.lineTo(mCanvas.width, y); bCtx.stroke(); }

                // ------------------------------------------------
                // ------------------------------------------------
                // UNIFIED PATH FILL RENDERING
                // ------------------------------------------------

                // 1. Define ONE massive path for all rooms/tunnels
                bCtx.beginPath();
                this.mapData.rooms.forEach(r => {
                    const ptrs = r.points || r.poly;
                    ptrs.forEach((p, i) => i === 0 ? bCtx.moveTo(p.x, p.y) : bCtx.lineTo(p.x, p.y));
                    bCtx.closePath(); // Close each room polygon
                });

                // 2. Single Fill (Treats entire set as one polygon)
                // This creates the opaque body of the map, solving any overlap opacity issues.
                bCtx.globalCompositeOperation = 'source-over';
                bCtx.fillStyle = 'rgba(30, 41, 59, 1)';
                bCtx.fill();

                // 3. STROKE the edges (Glow) BEHIND the fill
                // Using 'destination-over' ensures we only see the outer glow, and no internal overlap lines.
                bCtx.globalCompositeOperation = 'destination-over';
                bCtx.strokeStyle = CONFIG.colors.border;
                bCtx.lineWidth = 4; // Thicker for better glow visibility
                bCtx.shadowColor = CONFIG.colors.border;
                bCtx.shadowBlur = 25;
                bCtx.setLineDash([]); // Ensure solid line
                bCtx.stroke();

                // Reset
                bCtx.globalCompositeOperation = 'source-over';
                bCtx.shadowBlur = 0;

                this.bgImage = bCtx.canvas;
            }

            initFog() {
                if (!this.mapData) return;
                this.fogDetails = document.createElement('canvas');
                this.fogDetails.width = Math.max(6000, this.mapData.width);
                this.fogDetails.height = Math.max(6000, this.mapData.height);
                const ctx = this.fogDetails.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, this.fogDetails.width, this.fogDetails.height);
            }

            async loop() {
                try {
                    const state = await API.getState();
                    this.agents = state.agents || [];

                    // UI Updates
                    document.getElementById('antCount').innerText = this.agents.length;

                    // Timer UI
                    const ms = state.time || 0;
                    const mins = Math.floor(ms / 60000).toString().padStart(2, '0');
                    const secs = Math.floor((ms % 60000) / 1000).toString().padStart(2, '0');
                    const cents = Math.floor((ms % 1000) / 10).toString().padStart(2, '0');
                    const uiTimer = document.getElementById('timerDisplay');
                    uiTimer.innerText = `${mins}:${secs}.${cents}`;

                    if (state.completed) uiTimer.style.color = '#facc15'; // Yellow on finish
                    else uiTimer.style.color = '#22d3ee';

                    const total = state.total || 1;
                    const explored = state.explored || 0;
                    const pct = Math.floor((explored / total) * 100);
                    document.getElementById('explorePct').innerText = pct;
                    document.getElementById('progressFill').style.width = `${pct}%`;


                    const fCtx = this.fogDetails.getContext('2d');
                    fCtx.globalCompositeOperation = 'destination-out';

                    this.agents.forEach(a => {
                        const g = fCtx.createRadialGradient(a.x, a.y, 10, a.x, a.y, 60);
                        g.addColorStop(0, 'rgba(0,0,0,1)');
                        g.addColorStop(1, 'rgba(0,0,0,0)');
                        fCtx.fillStyle = g;
                        fCtx.beginPath();
                        fCtx.arc(a.x, a.y, 60, 0, Math.PI * 2);
                        fCtx.fill();
                    });
                    fCtx.globalCompositeOperation = 'source-over';

                } catch (e) { }

                this.render();
                requestAnimationFrame(() => this.loop());
            }

            render() {
                const { bg, ant, fog } = this.canvases;
                const w = bg.canvas.width, h = bg.canvas.height;
                bg.clearRect(0, 0, w, h); ant.clearRect(0, 0, w, h); fog.clearRect(0, 0, w, h);

                CAM.apply(bg);
                if (this.bgImage) bg.drawImage(this.bgImage, 0, 0);
                bg.restore();

                CAM.apply(ant);
                this.agents.forEach(a => {
                    const color = a.isRed ? CONFIG.colors.antRed : CONFIG.colors.ant;
                    ant.fillStyle = color;
                    ant.shadowColor = color;
                    ant.shadowBlur = 10;
                    ant.beginPath();
                    ant.arc(a.x, a.y, 3, 0, Math.PI * 2);
                    ant.fill();
                });
                ant.shadowBlur = 0;
                ant.restore();

                CAM.apply(fog);
                if (this.fogDetails) fog.drawImage(this.fogDetails, 0, 0);
                fog.restore();
            }
        }

        const CAM = {
            x: 0, y: 0, zoom: 0.3,
            apply(ctx) {
                ctx.save();
                ctx.translate(window.innerWidth / 2, window.innerHeight / 2);
                ctx.scale(this.zoom, this.zoom);
                ctx.translate(-this.x - window.innerWidth / 2, -this.y - window.innerHeight / 2);
            }
        };

        const ctr = document.getElementById('game-container');
        let isDrag = false, lx = 0, ly = 0;
        ctr.onmousedown = e => { isDrag = true; lx = e.clientX; ly = e.clientY; };
        window.onmouseup = () => isDrag = false;
        window.onmousemove = e => { if (isDrag) { CAM.x -= (e.clientX - lx) / CAM.zoom; CAM.y -= (e.clientY - ly) / CAM.zoom; lx = e.clientX; ly = e.clientY; } };
        ctr.onwheel = e => { CAM.zoom += e.deltaY * -0.001; CAM.zoom = Math.min(Math.max(0.1, CAM.zoom), 4); };

        document.getElementById('spawnBtn').onclick = () => API.spawn();
        document.getElementById('resetBtn').onclick = async () => { await API.reset(); client.mapData = await API.getMap(); MockServer.map = client.mapData; MockServer.reset(); client.drawStaticMap(); client.initFog(); };
        const modeLabel = document.getElementById('modeLabel');
        document.getElementById('toggleMockBtn').onclick = () => {
            CONFIG.useMock = !CONFIG.useMock;
            modeLabel.innerText = CONFIG.useMock ? "MODE: MOCK SERVER" : "MODE: REAL JAVA BACKEND";
            modeLabel.style.color = CONFIG.useMock ? "yellow" : "green";
            API.reset();
        };

        // MOCK SERVER (Updated with Exploration Logic)
        const MockServer = {
            map: null, agents: [],
            startTime: 0, endTime: 0, completed: false,
            start: function () { this.startTime = Date.now(); this.endTime = 0; this.completed = false; },
            getMap: function () { if (!this.map) this.genMap(); return this.map; },
            getState: function () {
                // Tracking
                let exploredCount = 0;
                const now = this.completed ? this.endTime : Date.now();
                const elapsed = now - this.startTime;

                this.agents.forEach(a => {
                    a.angle += (Math.random() - 0.5) * 0.2;
                    const nextX = a.x + Math.cos(a.angle) * 3;
                    const nextY = a.y + Math.sin(a.angle) * 3;

                    // Collision & Exploration
                    let valid = false;
                    for (let r of this.map.rooms) {
                        const poly = r.points || r.poly;
                        if (Physics.isPointInPolygon({ x: nextX, y: nextY }, poly)) {
                            valid = true;
                            if (!r.explored) r.explored = true;
                            break;
                        }
                    }

                    if (valid) { a.x = nextX; a.y = nextY; }
                    else { a.angle = Math.random() * Math.PI * 2; }
                });

                // Count
                if (this.map) {
                    this.map.rooms.forEach(r => { if (r.explored) exploredCount++; });
                    if (exploredCount >= this.map.rooms.length && !this.completed) {
                        this.completed = true;
                        this.endTime = Date.now();
                    }
                }

                return {
                    agents: this.agents,
                    time: elapsed,
                    explored: exploredCount,
                    total: this.map ? this.map.rooms.length : 0,
                    completed: this.completed
                };
            },
            spawn: function () {
                const isRed = Math.random() < 0.2;
                const start = this.map.rooms[0];
                let cx = 0, cy = 0;
                if (start.points) { start.points.forEach(p => { cx += p.x; cy += p.y }); cx /= start.points.length; cy /= start.points.length; }
                this.agents.push({ x: cx, y: cy, angle: 0, isRed });
            },
            reset: function () { this.agents = []; this.genMap(); this.start(); },
            genMap: function () {
                this.map = { width: 6000, height: 6000, rooms: [] };
                const nodes = [];
                const addRoom = (cx, cy, w, h) => {
                    const pts = []; const steps = 20;
                    for (let i = 0; i < steps; i++) {
                        let a = i / steps * 6.28; let n = 0.7 + Math.random() * 0.6;
                        pts.push({ x: cx + Math.cos(a) * w / 2 * n, y: cy + Math.sin(a) * h / 2 * n });
                    }
                    this.map.rooms.push({ points: pts, explored: false });
                    nodes.push({ x: cx, y: cy });
                };

                addRoom(3000, 200, 200, 120);
                this.map.rooms[0].explored = true; // Start room explored

                for (let i = 0; i < 50; i++) addRoom(200 + Math.random() * 5600, 400 + Math.random() * 5400, 150 + Math.random() * 150, 150 + Math.random() * 150);

                nodes.forEach((n, i) => {
                    if (i == 0) return;
                    let range = 1000, best = nodes[0];
                    for (let j = 0; j < i; j++) { let d = Math.hypot(n.x - nodes[j].x, n.y - nodes[j].y); if (d < range) { range = d; best = nodes[j]; } }
                    const p1 = n, p2 = best;
                    const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const w = 20;
                    const dx = Math.cos(ang + 1.57) * w; const dy = Math.sin(ang + 1.57) * w;
                    this.map.rooms.push({
                        points: [
                            { x: p1.x + dx, y: p1.y + dy }, { x: p2.x + dx, y: p2.y + dy }, { x: p2.x - dx, y: p2.y - dy }, { x: p1.x - dx, y: p1.y - dy }
                        ], explored: false
                    });
                });
            }
        };

        MockServer.start(); // Init timer logic
        modeLabel.innerText = "MODE: MOCK SERVER";
        const client = new GameClient();
    </script>
</body>

</html>