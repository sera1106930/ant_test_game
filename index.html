<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Ant Net</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0f172a;
            --accent-cyan: #22d3ee;
            --accent-red: #ef4444;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #uiLayer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud {
            position: absolute;
            top: 2rem;
            left: 2rem;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-left: 4px solid var(--accent-cyan);
            pointer-events: auto;
        }

        .controls {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            pointer-events: auto;
        }

        button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: cyan;
            border: 1px solid cyan;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px var(--accent-cyan);
        }

        .mock-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: yellow;
            font-size: 0.8rem;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="bgCanvas"></canvas>
        <canvas id="fogCanvas"></canvas>
        <canvas id="antCanvas"></canvas>
        <div id="uiLayer">
            <div class="mock-indicator" id="modeLabel">Connecting...</div>
            <div class="hud">
                <div>SYSTEM STATUS: <span style="color:#22d3ee">ONLINE</span></div>
                <div>AGENTS: <span id="antCount">0</span></div>
            </div>
            <div class="controls">
                <button id="resetBtn">REGENERATE NET</button>
                <button id="spawnBtn">DEPLOY AGENT</button>
                <button id="toggleMockBtn" style="border-color: yellow; color: yellow;">SWITCH TO REAL SERVER</button>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            useMock: true,
            apiBase: 'http://localhost:8080/api',
            colors: { bg: '#0f172a', ground: '#1e293b', ant: '#22d3ee', antRed: '#ef4444', border: '#22d3ee' }
        };

        const API = {
            getMap: async () => {
                if (CONFIG.useMock) return MockServer.getMap();
                const res = await fetch(`${CONFIG.apiBase}/map`);
                return res.json();
            },
            getState: async () => {
                if (CONFIG.useMock) return MockServer.getState();
                const res = await fetch(`${CONFIG.apiBase}/state`);
                return res.json();
            },
            spawn: async () => {
                if (CONFIG.useMock) return MockServer.spawn();
                await fetch(`${CONFIG.apiBase}/spawn`, { method: 'POST' });
            },
            reset: async () => {
                if (CONFIG.useMock) return MockServer.reset();
                await fetch(`${CONFIG.apiBase}/reset`, { method: 'POST' });
            }
        };

        // ------------------------------------------------------------------
        // PHYSICS ENGINE
        // ------------------------------------------------------------------
        const Physics = {
            isPointInPolygon: function (point, vs) {
                // ray-casting algorithm based on
                // https://github.com/substack/point-in-polygon
                var x = point.x, y = point.y;
                var inside = false;
                for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    var xi = vs[i].x, yi = vs[i].y;
                    var xj = vs[j].x, yj = vs[j].y;
                    var intersect = ((yi > y) != (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            },

            isValid: function (x, y, rooms) {
                for (let r of rooms) {
                    const poly = r.points || r.poly;
                    if (this.isPointInPolygon({ x, y }, poly)) return true;
                }
                return false;
            }
        };

        // ------------------------------------------------------------------
        // RENDERER
        // ------------------------------------------------------------------
        class GameClient {
            constructor() {
                this.canvases = {
                    bg: document.getElementById('bgCanvas').getContext('2d'),
                    fog: document.getElementById('fogCanvas').getContext('2d'),
                    ant: document.getElementById('antCanvas').getContext('2d')
                };
                this.mapData = null;
                this.agents = [];
                this.init();
            }

            async init() {
                window.onresize = () => this.resize();
                this.resize();

                this.mapData = await API.getMap();
                MockServer.map = this.mapData; // Sync for Client Prediction

                this.drawStaticMap();
                this.initFog();

                this.loop();
            }

            resize() {
                const w = window.innerWidth, h = window.innerHeight;
                for (let k in this.canvases) { this.canvases[k].canvas.width = w; this.canvases[k].canvas.height = h; }
                if (this.mapData) this.drawStaticMap();
            }

            drawStaticMap() {
                if (!this.mapData) return;

                const mCanvas = document.createElement('canvas');
                mCanvas.width = Math.max(3000, this.mapData.width);
                mCanvas.height = Math.max(3000, this.mapData.height);
                const mCtx = mCanvas.getContext('2d');

                mCtx.fillStyle = 'white';
                this.mapData.rooms.forEach(r => {
                    mCtx.beginPath();
                    const ptrs = r.points || r.poly;
                    ptrs.forEach((p, i) => i === 0 ? mCtx.moveTo(p.x, p.y) : mCtx.lineTo(p.x, p.y));
                    mCtx.closePath();
                    mCtx.fill();
                });

                const bCtx = document.createElement('canvas').getContext('2d');
                bCtx.canvas.width = mCanvas.width; bCtx.canvas.height = mCanvas.height;

                // Grid
                bCtx.strokeStyle = 'rgba(34, 211, 238, 0.05)';
                bCtx.lineWidth = 1;
                for (let x = 0; x < mCanvas.width; x += 100) { bCtx.beginPath(); bCtx.moveTo(x, 0); bCtx.lineTo(x, mCanvas.height); bCtx.stroke(); }
                for (let y = 0; y < mCanvas.height; y += 100) { bCtx.beginPath(); bCtx.moveTo(0, y); bCtx.lineTo(mCanvas.width, y); bCtx.stroke(); }

                // Ground
                bCtx.globalCompositeOperation = 'source-over';
                bCtx.fillStyle = CONFIG.colors.ground;
                this.mapData.rooms.forEach(r => {
                    bCtx.beginPath();
                    const ptrs = r.points || r.poly;
                    ptrs.forEach((p, i) => i === 0 ? bCtx.moveTo(p.x, p.y) : bCtx.lineTo(p.x, p.y));
                    bCtx.fill();
                });

                // Dashed Border
                bCtx.strokeStyle = CONFIG.colors.border;
                bCtx.lineWidth = 2;
                bCtx.setLineDash([5, 15]);
                bCtx.shadowColor = CONFIG.colors.border;
                bCtx.shadowBlur = 25;
                this.mapData.rooms.forEach(r => {
                    bCtx.beginPath();
                    const ptrs = r.points || r.poly;
                    ptrs.forEach((p, i) => i === 0 ? bCtx.moveTo(p.x, p.y) : bCtx.lineTo(p.x, p.y));
                    bCtx.closePath();
                    bCtx.stroke();
                });
                bCtx.shadowBlur = 0;
                bCtx.setLineDash([]);

                this.bgImage = bCtx.canvas;
            }

            initFog() {
                if (!this.mapData) return;
                this.fogDetails = document.createElement('canvas');
                this.fogDetails.width = Math.max(3000, this.mapData.width);
                this.fogDetails.height = Math.max(3000, this.mapData.height);
                const ctx = this.fogDetails.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, this.fogDetails.width, this.fogDetails.height);
            }

            async loop() {
                try {
                    const state = await API.getState();
                    this.agents = state.agents || [];
                    document.getElementById('antCount').innerText = this.agents.length;

                    const fCtx = this.fogDetails.getContext('2d');
                    fCtx.globalCompositeOperation = 'destination-out';

                    this.agents.forEach(a => {
                        const g = fCtx.createRadialGradient(a.x, a.y, 10, a.x, a.y, 60);
                        g.addColorStop(0, 'rgba(0,0,0,1)');
                        g.addColorStop(1, 'rgba(0,0,0,0)');
                        fCtx.fillStyle = g;
                        fCtx.beginPath();
                        fCtx.arc(a.x, a.y, 60, 0, Math.PI * 2);
                        fCtx.fill();
                    });
                    fCtx.globalCompositeOperation = 'source-over';

                } catch (e) { }

                this.render();
                requestAnimationFrame(() => this.loop());
            }

            render() {
                const { bg, ant, fog } = this.canvases;
                const w = bg.canvas.width, h = bg.canvas.height;
                bg.clearRect(0, 0, w, h); ant.clearRect(0, 0, w, h); fog.clearRect(0, 0, w, h);

                CAM.apply(bg);
                if (this.bgImage) bg.drawImage(this.bgImage, 0, 0);
                bg.restore();

                CAM.apply(ant);
                this.agents.forEach(a => {
                    const color = a.isRed ? CONFIG.colors.antRed : CONFIG.colors.ant;
                    ant.fillStyle = color;
                    ant.shadowColor = color;
                    ant.shadowBlur = 10;
                    ant.beginPath();
                    ant.arc(a.x, a.y, 3, 0, Math.PI * 2);
                    ant.fill();
                });
                ant.shadowBlur = 0;
                ant.restore();

                CAM.apply(fog);
                if (this.fogDetails) fog.drawImage(this.fogDetails, 0, 0);
                fog.restore();
            }
        }

        const CAM = {
            x: 0, y: 0, zoom: 0.6,
            apply(ctx) {
                ctx.save();
                ctx.translate(window.innerWidth / 2, window.innerHeight / 2);
                ctx.scale(this.zoom, this.zoom);
                ctx.translate(-this.x - window.innerWidth / 2, -this.y - window.innerHeight / 2);
            }
        };

        // Camera Logic
        let isDrag = false, lx = 0, ly = 0;
        const ctr = document.getElementById('game-container');
        ctr.onmousedown = e => { isDrag = true; lx = e.clientX; ly = e.clientY; };
        window.onmouseup = () => isDrag = false;
        window.onmousemove = e => {
            if (isDrag) { CAM.x -= (e.clientX - lx) / CAM.zoom; CAM.y -= (e.clientY - ly) / CAM.zoom; lx = e.clientX; ly = e.clientY; }
        };
        ctr.onwheel = e => { CAM.zoom += e.deltaY * -0.001; CAM.zoom = Math.min(Math.max(0.1, CAM.zoom), 4); };

        document.getElementById('spawnBtn').onclick = () => API.spawn();
        document.getElementById('resetBtn').onclick = async () => { await API.reset(); client.mapData = await API.getMap(); MockServer.map = client.mapData; client.drawStaticMap(); client.initFog(); };
        const modeLabel = document.getElementById('modeLabel');
        document.getElementById('toggleMockBtn').onclick = () => {
            CONFIG.useMock = !CONFIG.useMock;
            modeLabel.innerText = CONFIG.useMock ? "MODE: MOCK SERVER" : "MODE: REAL JAVA BACKEND";
            modeLabel.style.color = CONFIG.useMock ? "yellow" : "green";
            API.reset();
        };

        // MOCK SERVER (Updated with Physics)
        const MockServer = {
            map: null, agents: [],
            getMap: function () { if (!this.map) this.genMap(); return this.map; },
            getState: function () {
                // Client-side physics (Prediction/Simulation)
                this.agents.forEach(a => {
                    a.angle += (Math.random() - 0.5) * 0.2;
                    const nextX = a.x + Math.cos(a.angle) * 3;
                    const nextY = a.y + Math.sin(a.angle) * 3;

                    // Collision Check
                    if (Physics.isValid(nextX, nextY, this.map.rooms)) {
                        a.x = nextX; a.y = nextY;
                    } else {
                        a.angle = Math.random() * Math.PI * 2; // Bounce/Rotate
                    }
                });
                return { agents: this.agents };
            },
            spawn: function () {
                const isRed = Math.random() < 0.2;
                // Spawn at Map Center (Room 0)
                const start = this.map.rooms[0];
                // Simple avg of points for true center approximation if 'center' is missing
                let cx = 0, cy = 0;
                if (start.points) { start.points.forEach(p => { cx += p.x; cy += p.y }); cx /= start.points.length; cy /= start.points.length; }
                else { cx = 1500; cy = 200; }

                this.agents.push({ x: cx, y: cy, angle: 0, isRed });
            },
            reset: function () { this.agents = []; this.genMap(); },
            genMap: function () {
                // Client-Side High-Fidelity Gen (Use same logic as before but store 'points')
                this.map = { width: 3000, height: 3000, rooms: [] };
                const nodes = [];
                const addRoom = (cx, cy, w, h) => {
                    const pts = []; const steps = 20;
                    for (let i = 0; i < steps; i++) {
                        let a = i / steps * 6.28; let n = 0.7 + Math.random() * 0.6;
                        pts.push({ x: cx + Math.cos(a) * w / 2 * n, y: cy + Math.sin(a) * h / 2 * n });
                    }
                    this.map.rooms.push({ points: pts });
                    nodes.push({ x: cx, y: cy });
                };

                addRoom(1500, 200, 200, 120);
                for (let i = 0; i < 20; i++) addRoom(200 + Math.random() * 2600, 400 + Math.random() * 2400, 150 + Math.random() * 150, 150 + Math.random() * 150);

                // Simplified Tunnels (Rects for visibility in Mock)
                nodes.forEach((n, i) => {
                    if (i == 0) return;
                    let range = 1000, best = nodes[0];
                    for (let j = 0; j < i; j++) { let d = Math.hypot(n.x - nodes[j].x, n.y - nodes[j].y); if (d < range) { range = d; best = nodes[j]; } }
                    const p1 = n, p2 = best;
                    // Simple Box Tunnel
                    const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    const w = 20;
                    const dx = Math.cos(ang + 1.57) * w; const dy = Math.sin(ang + 1.57) * w;
                    this.map.rooms.push({
                        points: [
                            { x: p1.x + dx, y: p1.y + dy }, { x: p2.x + dx, y: p2.y + dy }, { x: p2.x - dx, y: p2.y - dy }, { x: p1.x - dx, y: p1.y - dy }
                        ]
                    });
                });
            }
        };

        modeLabel.innerText = "MODE: MOCK SERVER";
        const client = new GameClient();
    </script>
</body>

</html>