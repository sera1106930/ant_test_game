<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Ant Nest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0f172a;
            --text-color: #f8fafc;
            --accent-cyan: #22d3ee;
            --btn-bg: rgba(15, 23, 42, 0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #game-container:active {
            cursor: grabbing;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Order: Map -> Fog -> Ants */
        #bgCanvas {
            z-index: 1;
        }

        #fogCanvas {
            z-index: 2;
            opacity: 1;
        }

        #antCanvas {
            z-index: 3;
        }

        #uiLayer {
            z-index: 10;
            pointer-events: none;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .hud-panel {
            position: absolute;
            top: 2rem;
            left: 2rem;
            padding: 1rem 1.5rem;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(8px);
            border-left: 4px solid var(--accent-cyan);
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.1);
            pointer-events: auto;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #94a3b8;
            font-weight: 600;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: white;
            font-family: monospace;
        }

        .controls {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: flex-end;
            pointer-events: auto;
        }

        button {
            background: var(--btn-bg);
            color: var(--accent-cyan);
            border: 1px solid var(--accent-cyan);
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.2);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
        }

        button:hover {
            background: rgba(34, 211, 238, 0.15);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-danger {
            color: #ef4444;
            border-color: #ef4444;
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.15);
        }

        .icon {
            width: 1.25em;
            height: 1.25em;
            fill: currentColor;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(to bottom, transparent 0, transparent 2px, rgba(0, 0, 0, 0.1) 3px);
            pointer-events: none;
            z-index: 9;
            opacity: 0.3;
        }

        .hint {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="bgCanvas"></canvas>
        <canvas id="fogCanvas"></canvas>
        <canvas id="antCanvas"></canvas>

        <div class="scanlines"></div>

        <div id="uiLayer">
            <div class="hud-panel">
                <div class="stat-label">系統 AGENT 總數</div>
                <div class="stat-value" id="antCount">0</div>
            </div>

            <div class="controls">
                <button id="resetBtn" class="btn-danger">
                    <svg class="icon" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd"
                            d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z"
                            clip-rule="evenodd" />
                    </svg>
                    RESET WORLD
                </button>
                <button id="spawnBtn">
                    <svg class="icon" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" />
                    </svg>
                    Deploy Agent
                </button>
            </div>

            <div class="hint">DRAG TO PAN • SCROLL TO ZOOM</div>
        </div>
    </div>

    <script>
        /**
         * ------------------------------------------------------------------
         * CONFIG
         * ------------------------------------------------------------------
         */
        const CONFIG = {
            colors: {
                bg: '#0f172a',
                fog: '#000000',
                ant: '#22d3ee',
                wall: '#06b6d4',
                ground: '#1e293b'
            },
            world: {
                width: 3000,
                height: 3000,
                roomCount: 20
            }
        };

        /**
         * ------------------------------------------------------------------
         * MATH UTILS
         * ------------------------------------------------------------------
         */
        const Vec2 = {
            add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
            sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
            dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
            mult: (v, s) => ({ x: v.x * s, y: v.y * s }),
            dist: (v1, v2) => Math.hypot(v1.x - v2.x, v1.y - v2.y),
            norm: (v) => {
                const l = Math.hypot(v.x, v.y);
                return l === 0 ? { x: 0, y: 0 } : { x: v.x / l, y: v.y / l };
            },
            normal: (p1, p2) => {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                return Vec2.norm({ x: -dy, y: dx });
            }
        };

        function getIntersection(p1, p2, p3, p4) {
            const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denom == 0) return null;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
            }
            return null;
        }

        // Point inside polygon check (Ray Casting)
        function isPointInPoly(pt, poly) {
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                const xi = poly[i].x, yi = poly[i].y;
                const xj = poly[j].x, yj = poly[j].y;
                const intersect = ((yi > pt.y) != (yj > pt.y)) && (pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        /**
         * ------------------------------------------------------------------
         * MAP DATA (MST Generation + Smart Collision)
         * ------------------------------------------------------------------
         */
        class MapData {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.rooms = []; // All Shapes (Rooms + Tunnels)
                this.generateMSTMap();
            }

            generateMSTMap() {
                this.rooms = [];
                const nodes = [];

                // 1. Scatter Rooms
                // Always create a Surface Start Room
                const surfaceRoom = this.createRoom(this.width / 2, 200, 200, 120);
                nodes.push({ x: this.width / 2, y: 200, id: 0 });
                this.rooms.push(surfaceRoom);

                // Create Random Rooms
                for (let i = 1; i < CONFIG.world.roomCount; i++) {
                    const cx = 200 + Math.random() * (this.width - 400);
                    const cy = 400 + Math.random() * (this.height - 600);

                    const w = 150 + Math.random() * 200;
                    const h = 150 + Math.random() * 200;

                    const room = this.createRoom(cx, cy, w, h);
                    this.rooms.push(room);
                    nodes.push({ x: cx, y: cy, id: i });
                }

                // 2. Minimum Spanning Tree (Prim's Algorithm)
                const edges = [];
                const reached = new Set([0]); // Start with node 0
                const unreached = new Set(nodes.slice(1).map(n => n.id));

                while (unreached.size > 0) {
                    let minDist = Infinity;
                    let bestEdge = null;
                    let bestNodeIndex = -1;

                    for (const rId of reached) {
                        const rNode = nodes[rId];
                        for (const uId of unreached) {
                            const uNode = nodes[uId];
                            const d = Vec2.dist(rNode, uNode);
                            if (d < minDist) {
                                minDist = d;
                                bestEdge = { p1: rNode, p2: uNode };
                                bestNodeIndex = uId;
                            }
                        }
                    }

                    if (bestEdge) {
                        edges.push(bestEdge);
                        reached.add(bestNodeIndex);
                        unreached.delete(bestNodeIndex);
                    } else {
                        break; // Should not happen
                    }
                }

                // 3. Add Extra Random Lines (Cycles)
                // Connect some close nodes that aren't directly connected
                const extraEdges = Math.floor(nodes.length * 0.3);
                for (let k = 0; k < extraEdges; k++) {
                    const id1 = Math.floor(Math.random() * nodes.length);
                    const id2 = Math.floor(Math.random() * nodes.length);
                    if (id1 !== id2) {
                        edges.push({ p1: nodes[id1], p2: nodes[id2] });
                    }
                }

                // 4. Create Tunnels for Edges
                edges.forEach(edge => {
                    this.rooms.push(this.createTunnel(edge.p1, edge.p2, 60));
                });
            }

            createRoom(cx, cy, w, h) {
                const points = [];
                const steps = 12; // Hexagon+ ish
                for (let i = 0; i < steps; i++) {
                    const ang = (i / steps) * Math.PI * 2;
                    // Irregularity
                    const radX = (w / 2) * (0.8 + Math.random() * 0.4);
                    const radY = (h / 2) * (0.8 + Math.random() * 0.4);
                    points.push({
                        x: cx + Math.cos(ang) * radX,
                        y: cy + Math.sin(ang) * radY
                    });
                }
                return { points, type: 'room', center: { x: cx, y: cy } };
            }

            createTunnel(p1, p2, width) {
                const norm = Vec2.normal(p1, p2);
                const offset = Vec2.mult(norm, width / 2);
                return {
                    points: [
                        Vec2.add(p1, offset),
                        Vec2.add(p2, offset),
                        Vec2.sub(p2, offset),
                        Vec2.sub(p1, offset)
                    ],
                    type: 'tunnel'
                };
            }

            // Is Point inside ANY room (Union)?
            isValidPosition(x, y) {
                const pt = { x, y };
                for (const room of this.rooms) {
                    if (isPointInPoly(pt, room.points)) return true;
                }
                return false;
            }

            // Smart Collision: Ignores internal walls
            checkCollision(p1, p2) {
                if (this.isValidPosition(p2.x, p2.y)) return null;

                let bestHit = null;
                let minDst = Infinity;

                // Check ALL walls
                for (const room of this.rooms) {
                    const pts = room.points;
                    for (let i = 0; i < pts.length; i++) {
                        const w1 = pts[i];
                        const w2 = pts[(i + 1) % pts.length];

                        const hit = getIntersection(p1, p2, w1, w2);
                        if (hit) {
                            // CRITICAL: Check if this wall is actually inside ANOTHER room
                            // Shift hit point slightly into the "other side" to see if it's void or solid?
                            // Better: Check if the Hit Point itself is inside any OTHER polygon (with a small epsilon)

                            // Let's verify if the wall midpoint is inside another poly.
                            const mid = { x: (w1.x + w2.x) / 2, y: (w1.y + w2.y) / 2 };
                            let isInternal = false;

                            for (const otherRoom of this.rooms) {
                                if (otherRoom === room) continue;
                                if (isPointInPoly(hit, otherRoom.points)) {
                                    isInternal = true;
                                    break;
                                }
                            }

                            if (!isInternal) {
                                const dst = Vec2.dist(p1, hit);
                                if (dst < minDst) {
                                    minDst = dst;
                                    bestHit = { pos: hit, normal: Vec2.normal(w1, w2) };
                                }
                            }
                        }
                    }
                }

                if (!bestHit) {
                    // Fallback bounce
                    return { pos: p1, normal: Vec2.norm(Vec2.sub(p1, p2)) };
                }
                return bestHit;
            }
        }

        /**
         * ------------------------------------------------------------------
         * ANT & GAME
         * ------------------------------------------------------------------
         */
        class Ant {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 2 + Math.random() * 2;
            }

            update(mapData) {
                this.angle += (Math.random() - 0.5) * 0.2;
                const vx = Math.cos(this.angle) * this.speed;
                const vy = Math.sin(this.angle) * this.speed;

                const nextX = this.x + vx;
                const nextY = this.y + vy;

                const collision = mapData.checkCollision({ x: this.x, y: this.y }, { x: nextX, y: nextY });

                if (collision) {
                    const n = collision.normal;
                    const v = { x: vx, y: vy };
                    const dot = Vec2.dot(v, n);
                    const r = Vec2.sub(v, Vec2.mult(n, 2 * dot));

                    this.angle = Math.atan2(r.y, r.x);
                    this.x = collision.pos.x + n.x * 2;
                    this.y = collision.pos.y + n.y * 2;
                } else {
                    this.x = nextX;
                    this.y = nextY;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.colors.ant;
                ctx.shadowColor = CONFIG.colors.ant;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Camera {
            constructor() {
                this.x = CONFIG.world.width / 2 - window.innerWidth / 2;
                this.y = 0;
                this.zoom = 0.6; // Improved start zoom
                this.isDragging = false;
                this.lastMouse = { x: 0, y: 0 };

                const el = document.getElementById('game-container');
                el.addEventListener('mousedown', e => {
                    this.isDragging = true;
                    this.lastMouse = { x: e.clientX, y: e.clientY };
                    el.style.cursor = 'grabbing';
                });
                window.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    el.style.cursor = 'grab';
                });
                window.addEventListener('mousemove', e => {
                    if (!this.isDragging) return;
                    const dx = e.clientX - this.lastMouse.x;
                    const dy = e.clientY - this.lastMouse.y;
                    this.x -= dx / this.zoom;
                    this.y -= dy / this.zoom;
                    this.lastMouse = { x: e.clientX, y: e.clientY };
                });
                el.addEventListener('wheel', e => {
                    e.preventDefault();
                    const zoomSpeed = 0.001;
                    this.zoom += e.deltaY * -zoomSpeed;
                    this.zoom = Math.min(Math.max(0.1, this.zoom), 3);
                });
            }

            apply(ctx) {
                ctx.save();
                ctx.translate(window.innerWidth / 2, window.innerHeight / 2);
                ctx.scale(this.zoom, this.zoom);
                ctx.translate(-this.x - window.innerWidth / 2, -this.y - window.innerHeight / 2);
            }
        }

        class Game {
            constructor() {
                this.canvases = {
                    bg: document.getElementById('bgCanvas').getContext('2d'),
                    fog: document.getElementById('fogCanvas').getContext('2d'),
                    ant: document.getElementById('antCanvas').getContext('2d')
                };

                this.maskCanvas = document.createElement('canvas');
                this.staticBg = document.createElement('canvas');

                this.resize();

                this.map = new MapData(CONFIG.world.width, CONFIG.world.height);
                this.camera = new Camera();
                this.ants = [];

                this.drawStaticMap();
                this.fillFog();

                window.addEventListener('resize', () => {
                    this.resize();
                    this.drawStaticMap();
                    this.fillFog();
                });

                document.getElementById('spawnBtn').addEventListener('click', () => this.deploy());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                for (let k in this.canvases) {
                    this.canvases[k].canvas.width = w;
                    this.canvases[k].canvas.height = h;
                }
                this.maskCanvas.width = CONFIG.world.width;
                this.maskCanvas.height = CONFIG.world.height;
                this.staticBg.width = CONFIG.world.width;
                this.staticBg.height = CONFIG.world.height;
            }

            reset() {
                this.ants = [];
                this.map = new MapData(CONFIG.world.width, CONFIG.world.height);
                this.drawStaticMap();
                this.fillFog();
                document.getElementById('antCount').innerText = 0;
            }

            deploy() {
                // Deploy in Surface Room (always index 0)
                const room = this.map.rooms[0];
                this.ants.push(new Ant(room.center.x, room.center.y));
                document.getElementById('antCount').innerText = this.ants.length;
            }

            drawStaticMap() {
                const mCtx = this.maskCanvas.getContext('2d');
                mCtx.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);

                mCtx.fillStyle = '#ffffff';
                this.map.rooms.forEach(room => {
                    mCtx.beginPath();
                    room.points.forEach((p, i) => {
                        if (i === 0) mCtx.moveTo(p.x, p.y);
                        else mCtx.lineTo(p.x, p.y);
                    });
                    mCtx.closePath();
                    mCtx.fill();
                });

                const bCtx = this.staticBg.getContext('2d');
                bCtx.clearRect(0, 0, CONFIG.world.width, CONFIG.world.height);

                bCtx.save();
                bCtx.shadowBlur = 20;
                bCtx.shadowColor = CONFIG.colors.wall;
                bCtx.drawImage(this.maskCanvas, 0, 0);
                bCtx.restore();

                bCtx.globalCompositeOperation = 'source-over';
                bCtx.fillStyle = CONFIG.colors.ground;
                this.map.rooms.forEach(room => {
                    bCtx.beginPath();
                    room.points.forEach((p, i) => {
                        if (i === 0) bCtx.moveTo(p.x, p.y);
                        else bCtx.lineTo(p.x, p.y);
                    });
                    bCtx.closePath();
                    bCtx.fill();
                });
            }

            fillFog() {
                this.worldFog = document.createElement('canvas');
                this.worldFog.width = CONFIG.world.width;
                this.worldFog.height = CONFIG.world.height;
                this.fogCtx = this.worldFog.getContext('2d');
                this.fogCtx.fillStyle = 'black';
                this.fogCtx.fillRect(0, 0, CONFIG.world.width, CONFIG.world.height);
            }

            loop() {
                const { bg, ant, fog } = this.canvases;
                const w = window.innerWidth, h = window.innerHeight;

                this.ants.forEach(a => {
                    a.update(this.map);
                    this.fogCtx.globalCompositeOperation = 'destination-out';
                    this.fogCtx.beginPath();
                    this.fogCtx.arc(a.x, a.y, 80, 0, Math.PI * 2); // Big Reveal
                    this.fogCtx.fillStyle = 'black';
                    this.fogCtx.fill();
                    this.fogCtx.globalCompositeOperation = 'source-over';
                });

                bg.clearRect(0, 0, w, h);
                ant.clearRect(0, 0, w, h);
                fog.clearRect(0, 0, w, h);

                this.camera.apply(bg);
                bg.drawImage(this.staticBg, 0, 0);
                bg.restore();

                this.camera.apply(ant);
                this.ants.forEach(a => a.draw(ant));
                ant.restore();

                fog.save();
                this.camera.apply(fog);
                fog.drawImage(this.worldFog, 0, 0);
                fog.restore();

                requestAnimationFrame(this.loop);
            }
        }

        const game = new Game();

    </script>
</body>

</html>